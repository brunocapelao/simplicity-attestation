// ═══════════════════════════════════════════════════════════════════════════
// SIMPLICITY ATTESTATION - Delegation Vault
// ═══════════════════════════════════════════════════════════════════════════
//
// Sistema de atestações on-chain com delegação hierárquica.
// Protocolo: SAID (Simplicity Attestation ID) v1.0
//
// FUNCIONALIDADES:
// - Admin (Alice): Pode gastar fundos livremente (controle total)
// - Delegate (Bob): Pode emitir atestações com dados on-chain
//
// ESTRUTURA DE TRANSAÇÃO DO DELEGATE:
// - OUTPUT 0: Vault (self)         → Preserva a delegação
// - OUTPUT 1: Attestation (UTXO)   → Pode ser revogada
// - OUTPUT 2: OP_RETURN            → SAID Protocol: "SAID" + version + type + CID
// - OUTPUT 3: Fee                  → Taxa de rede
//
// FORMATO OP_RETURN (SAID Protocol):
// ┌────────┬─────────┬──────────┬─────────────────────────┐
// │  SAID  │ VERSION │   TYPE   │        PAYLOAD          │
// │ 4 bytes│  1 byte │  1 byte  │    CID IPFS (46+ bytes) │
// └────────┴─────────┴──────────┴─────────────────────────┘
//
// ═══════════════════════════════════════════════════════════════════════════

fn checksig(pk: Pubkey, sig: Signature) {
    let msg: u256 = jet::sig_all_hash();
    jet::bip_0340_verify((pk, msg), sig);
}

// ═══════════════════════════════════════════════════════════════════════════
// CAMINHO DO ADMIN - PODER TOTAL
// ═══════════════════════════════════════════════════════════════════════════

fn admin_spend(admin_sig: Signature) {
    // Admin pode gastar para qualquer destino, sem restrições
    let admin_pk: Pubkey = 0xbcc13efe121b35c7270c41ce63dab7688c0326c58c5f5e1d1af317c1503cad45;
    checksig(admin_pk, admin_sig);
}

// ═══════════════════════════════════════════════════════════════════════════
// CAMINHO DO DELEGATE - EMISSÃO DE CERTIFICADO
// ═══════════════════════════════════════════════════════════════════════════

fn delegate_issue_certificate(delegate_sig: Signature) {
    // VALIDAÇÃO 1: Exatamente 4 outputs
    let num_outs: u32 = jet::num_outputs();
    assert!(jet::eq_32(num_outs, 4));

    // VALIDAÇÃO 2: Output 0 deve ser o próprio vault (self)
    let self_hash: u256 = jet::current_script_hash();
    let maybe_output0: Option<u256> = jet::output_script_hash(0);
    match maybe_output0 {
        Some(out_hash: u256) => assert!(jet::eq_256(self_hash, out_hash)),
        None => panic!(),
    };

    // VALIDAÇÃO 3: Output 1 deve ser o contrato de certificado
    // CERTIFICATE_SCRIPT_HASH: Hash do script certificate.simf compilado
    // IMPORTANTE: Atualizar após compilar certificate.simf!
    let cert_script_hash: u256 = 0x0000000000000000000000000000000000000000000000000000000000000000;
    let maybe_output1: Option<u256> = jet::output_script_hash(1);
    match maybe_output1 {
        Some(cert_hash: u256) => assert!(jet::eq_256(cert_script_hash, cert_hash)),
        None => panic!(),
    };

    // VALIDAÇÃO 4: Output 2 deve conter dados (OP_RETURN com CID IPFS)
    // output_null_datum retorna Option<Option<Either<(u2, u256), Either<u1, u4>>>>
    // Verificamos apenas se há algum dado (Some(Some(_)))
    let output_idx: u32 = 2;
    let datum_idx: u32 = 0;
    let maybe_datum: Option<Option<Either<(u2, u256), Either<u1, u4>>>> = jet::output_null_datum(output_idx, datum_idx);
    match maybe_datum {
        Some(inner_opt: Option<Either<(u2, u256), Either<u1, u4>>>) => {
            match inner_opt {
                Some(datum: Either<(u2, u256), Either<u1, u4>>) => { /* Dados existem */ },
                None => panic!(),
            };
        },
        None => panic!(),
    };

    // VALIDAÇÃO 5: Output 3 deve ser taxa (fee)
    let maybe_fee: Option<bool> = jet::output_is_fee(3);
    match maybe_fee {
        Some(is_fee: bool) => assert!(is_fee),
        None => panic!(),
    };

    // VALIDAÇÃO 6: Assinatura do Delegate
    let delegate_pk: Pubkey = 0x8577f4e053850a2eb0c86ce4c81215fdec681c28e01648f4401e0c47a4276413;
    checksig(delegate_pk, delegate_sig);
}

// ═══════════════════════════════════════════════════════════════════════════
// PONTO DE ENTRADA
// ═══════════════════════════════════════════════════════════════════════════

fn main() {
    match witness::ADMIN_OR_DELEGATE {
        Left(admin_sig: Signature) => admin_spend(admin_sig),
        Right(delegate_sig: Signature) => delegate_issue_certificate(delegate_sig),
    }
}
